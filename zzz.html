<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>观察者模式</title>
</head>

<body>



  <script>
    // class Observe {
    //   constructor() {
    //     this.cabs = {}
    //   }
    //   on(name, fn) {
    //     if (!this.cabs[name]) {
    //       this.cabs[name] = []
    //       this.cabs[name].push(fn)
    //     }
    //   }
    //   off(name) {
    //     // this.cabs = this.cabs.filter(el => el !== fn)
    //     if (this.cabs[name]) {
    //       this.cabs[name] = null
    //     }
    //   }
    //   emit(name, arg) {
    //     const arr = this.cabs[name]
    //     if (arr) {
    //       arr.forEach(element => {
    //         element.call(this, arg)
    //       });
    //     }
    //   }
    // }

    // //就是 on先绑定事件， emit 触发事件，off 解绑    说实话简单

    // const app = new Observe()
    // app.on('click', () => {
    //   console.log("这是绑定的click事件");
    // })
    // app.on('down', () => {
    //   console.log("这是绑定的down事件");
    // })


    // setTimeout(() => {
    //   app.emit('click', 123)
    // }, 3000);

    function add(a, b, c){
      return a+b+c
    }

    

    //偏函数
    //它是指使用一个函数并将其应用一个或多个参数，
    //但不是全部参数，在这个过程中创建一个新函数，这个函数用于接受剩余的参数
    //另一种解释：是指将一些参数固定到一个函数，产生另一个较小的函数的过程

    //arr.slice 并不会修改原来的数组，而是返回新的数组，splice会修改原来的数组
    
    function m(a, b){
      return a*b
    }
    //也就是说，

    // let double = m._bind(null)
    // console.log(double(5,3));//10

    const obj = {
      a:123
    }
    function aaa(x){
      console.log(this.a*x,'222');
    }


    Function.prototype._bind = function(){
      const me = this //保留原来的函数的 this
      const params = [].slice.call(arguments)
      let target = params[0]
      let args = params.slice(1)
      const bindFn = function(){
        this.a = 6
        args = args.concat([].slice.call(arguments))
        if(this instanceof bindFn){
          target = this
        }
        return me.apply(target, args)
      }
      if(me.prototype){
        bindFn.prototype = Object.create(me.prototype)
      }
      return bindFn
    }

    const bind = aaa._bind(obj, 2)
    const bb = new bind()
    console.log(bb);
    
    //函数组合  每个函数执行后的输出，作为下一个函数的的参数
    
    //当前函数运行，需要依赖参数的运行结果，

    function curry(fn, arr){
      let args = arr || []
      const len = fn.length
      return function(){
        let args2 = [].slice.call(arguments)
        args2 = args.concat(args2)
        if(len > args2.length){
          return curry.call(null,fn, args2)
        }else {
          return fn.apply(null, args2)
        }
      }
    }

    const a = curry(add)
    console.log(a(1,2)(3),'+++');
    console.log(a(1,2)(3),'+++');

  

  </script>
</body>

</html>