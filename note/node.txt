libuv:
  1，libuv辅助js进行调度
  2，libuv对系统的异步i/o进行了封装
  3，application，调用的都是v8里面的引擎，
  4，引擎通过绑定nodejs，绑定到操作系统上面
  5，然后进入到libuv控制的事件队列
  6，libuv单独开个进程辅助js调度，对windows linux事件调度的通知
  7，libuv封装的是操作系统的底层
  8，libuv通过事件循环，把每一个事件送出去执行

  二：
  1，进入libuv，线注册到回调函数里面
    a，settimeout，settimeinterval 线程池不参与
    b，process.nextTrick()，每次调用放入队列中，
        下一轮循环中取出
    c，settimediate 比 process.nextTrick 优先级低
    d，node实现一个sleep ？

  node适用于I/O密集型，不适用于 cpu密集型
    1，IO密集型指的是系统的CPU性能相对硬盘、内存要好很多
    2，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作
    3，I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低
    4，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力
    5，时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片
    6，即该进程允许运行的时间，使各个程序从表面上看是同时进行的
    7，如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。
    8，如果进程在时间片结束前阻塞或结束，则CPU当即进行切换而不会造成CPU资源浪费
    9，在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
    10，但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分
    11，如何处理公平，一种方法就是引入时间片，每个程序轮流执行


  node中的事件循环：
    首先：非阻塞IO，就是异步IO，传统
    1，node基于多子线程的方式去解决了非阻塞I/O的问题
    2，应用层(主线程)发起I/O请求后，就不再过问情况了。然后让子线程来完成数据获取
    3，那主线程是去哪里检查呢，这里就要引入观察者这个概念，每次事件循环中有一个或者多个观察者
    4，事件循环是一个典型的生产/消费模型，异步I/O、网络请求等是事件的生产者，
    5，这些事件被传递到对应的观察者那里，等待事件循环取出并处理
    
  主线程生产事件到消费事件这个过程中，发生了什么？
    1，当调用异步IO时候，会创建一个请求对象，
    2，该对象包含了传入的参数和当前方法上下文，以及我们最关注的回调函数。
    3，创建完成后，推入线程池中等待执行。至此，主线程的调用立即返回，继续执行当前任务的后续操作。
    4，当线程池中有可用线程池时，会对请求对象进行调用
    5，执行完毕后，会将执行结果记录在对象中，归还线程，并且告诉观察者自己已经ready，
        然后观察者会把它放入队列中
    6，当主线程来询问观察者时，就可以取出请求对象，并且执行上面的回调函数。
        至此，整个异步I/O的流程就结束了
  总结：
    1，线程池有可用线程会执行之前调用的异步IO，执行完毕告诉观察者。
    2，当主线程询问观察者时，取出相应函数并且执行


  观察者：
    1，观察者负责将事件分类
    2，idle观察者，process nexttick()
        效率最高，消耗资源少，但是会阻塞cpu的后续调度
    3，io观察者 settimeout
        精确度不高，可能会延迟执行，启用了红黑树，消耗大
    4，check观察者 setmediate
        消耗的资源小，不会造成阻塞，效率低

    5，idle > Promise > io > check
    6,微任务：process.nextTick, promise, Object.observe,
      MutationObserver
  
  所以，node事件循环：
    1，首先，v8解析js，
    2，调用nodejs api，
    3，libuv负责node api的执行。他将不同的任务分配给不同的线程，形成一个 事件循环。
        以异步的方式将任务的执行结果返回给v8.
    
      libuv的事件循环分为6个阶段，他们会按照顺序反复运行。每当进入某一个阶段，都会从对应的
    回调队列中取出函数去执行，当队列为空或者执行的回调函数的数量达到系统设定的阈值，就会进入
    下一阶段。共有六个阶段：
    1，timers：(settimeout,setintervar)的回调，并且是由poll阶段控制的（宏任务）
    2，I/O callbacks：处理上一轮循环中少数未执行的 IO回调（宏任务）
    3，idle，prepare：node内部使用（微任务）
    4，poll：获取新的IO事件，适当条件下，node将阻塞在这里
    5，check：处理setmediate的回调（宏任务）
    6，close callback：执行socket的close事件（宏任务）
    7，其他微任务：promise，

    总结：事件循环流程：
    1，执行全局js同步代码
    2，执行微任务，先执行nexttick，再执行其他微任务
    3，开始执行宏任务，从第一个阶段执行相应宏任务中的所有任务，这里是所有每个阶段宏任务队列
        中的所有任务，（浏览器的事件循环只是取宏任务队列中的第一个任务出来执行，每一个阶段的
        宏任务执行完毕后，开始执行微任务，也就是步骤2）
    4，timers --> 步骤2 --> IO callback --> 步骤2 --> check --> 步骤2 --> close callback
        --> 步骤2 --> timers ... 循环往复

  那么 浏览器呢？
    1，js任务分为同步和异步
    2，同步任务是直接放在主线程上面，排队依次执行下去，异步任务是放在队列中。
    3，如果有多个异步队列，排队等候
    4，异步任务队列会被放到调用栈然后主线程执行调用栈任务

  流程总结：
    1，某个宏任务队列执行完后，会查看是否有微任务队列。
    2，如果有，会执行微任务中的所有任务，没有则读取宏任务队列中的首个任务。
    3，执行宏任务过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，
        以此类推


1-11 再次node
 node可能会调用浏览器的api，因此需要同步+异步才能完成
 1，js先用v8解析，
 2，node在v8外面封装一层api，供v8使用，再交给操作系统。比如，发请求
 3，底层操作系统，在拿到数据的时候 需要给出响应，这时候就需要时件循环
 4，node真正做的事情，就是提供一套机制，过渡，链接作用，再加上libuv
 5，libuv会给一个个事件放到事件队列中等待调用。一直轮询，回调。
 6，队列只能从两端进行操作，不一定所有队列都从两端拿。libuv轮询的是环形队列
 7，nodejs本身是多任务的，v8是单任务的，v8是一个线程，libuv是一个线程。
 8，v8，libuv，work-thread 相互运行自己的，由node  bindings 维护他们
 9，事件循环————v8注册————nbinding放到队列中
 10，读写文件，需要node操作底层系统，也是独立线程。
 11，v8————libuv————work————（work完成后交给libuv）————v8

非阻塞IO
  1，

nodejs结构：
  1，nodejs的主进程，是操作v8的，其他线程处理消息，io，异步操作
  2，node  bindings node的框架，相当于是管理了 v8+异步io+事件循环+dns



GC:
  1，新生代
  2，v8把内存分为新生代和老生代，新生代存放存活较短的变量，老生代存活较久的变量
  3，新生代通过算法分为两个空间 from，to
  4，处于使用的称为 from，处于闲置的称为 to
  5，开始回收时，检查from中存活的对象赋值到to，释放无用的变量。
  6，from to互换位置。
  7，再次进行回收，发现被回收过的或者to空间使用超过25%，直接晋升。
  8，缺点是只能使用堆内存的一半

  1，老生代
  2，老生代主要采用mark-sweep和mark-compact
  3，mark-sweep就是标记清除。标记那些死亡的对象，然后清除。
  4，清除后会出现内存不连续的现象，使用mark-compact压缩
  5，mark-compact 现将活着的对象移动到一边。然后直接清理边界外的内存

koa的几个中间件：
  koa-static:
    1，通过路径寻找文件，确定静态文件夹位置
    2，通过url获取文件的类型 .html .png
    3，把content-type 修改为 相应的类型
    4，通过fs读取文件并且返回





