流程：
  提示：1，计算机是不能认识url的，需要DNS解析出ip地址。
        2，复制大文件快，资源集中在磁盘的一个扇区上面，涉及到寻址操作。
        3，tcp的特性，刚开始速度快，后面速度慢，所以网络文件尽量小一点
  
  http：
    1.0与1.1的区别：
      1，缓存处理，1.0只要使用expires，1.1 e-tag
      2，长链接，keep-alive
      3，新增状态码
      4，优化带宽3

    2.0与1.1的区别：
      1，二进制传输
      2，服务端推送
      3，多路复用
      4，头部压缩

  a：浏览器本地的操作
    1，Prompt for unload
      我们在页面输入url的时候，首先会卸载掉原来的页面。
      目的是释放原来页面占据的内存。
    2，redirect
      先从本地缓存中查找请求内容，事实上，每次从网络请求文件后，文件都会被缓存在一个指定区域。
      优化IO操作，让cpu少做网络请求
    3，App cache
      网络操作，I/O 是最慢的操作

  b：网络操作 I/O
    1，DNS
      将url解析成ip地址
      CDN：
    2，TCP
      拿到ip地址后，建立tcp链接，想要进行http请求，必须进行tcp链接，tcp属于链路层，http应用层
      tcp作用就是链接对应的服务器ip地址
      tcp的特性，刚开始速度快，后面速度慢，所以网络文件尽量小一点
      五层协议：物理层，数据链路层（原始数据包），网络层，传输层，应用层

      发送方：发送一个url，应用层封装http协议头，http层封装相当于在url外面包了一层东西，向下传给传输层，
              传输层再次封包传给网络层，一直到物理层，转化为电信号。传给另一端。
      接收方：物理层接收，向上传到ip层，到网络层分包，再向上到tcp，tcp需要知道这个包的数据是哪个进程所需要的。
              浏览器拿到后，取出数据，给浏览器。
      如果有的包发送出错，会重新传送。

      传说中的三次握手：
        seq number：int  顺序号：一个int四个字节，主动发起方维护
        ack number：int  应答号：被动连接放维护   seq + ack  保证了发送双方的关系

        机制：发起连接的是客户端
          首先客户端客户端发起一个SYN指令，发送一个顺序号 seq = x，发送后，客户端处于半链接状态，等待响应
          服务端一直在监听有没有包发过来。收到包的时候 响应SYN_RCVE，应答号为 ACK = x+1，并且发送一个自己的 seq = y
          收到响应后，需要告诉服务器，发送一个应答号 ACK = y+1
          双方都有一个顺序号，响应号都是在顺序号的基础上面+1
      
      传送中的四次挥手：
        首先客户端发送 FIN指令，seq = x+2（因为握手的时候响应的ACK = x+1），ACK=y+1 表示自己将要断开
        服务端收到指令，首先响应客户端 ACK=x+3，
        服务端收尾完成就会发送一个FIN的包给客户端 seq=y+1（这里是响应之前客户端响应服务端的号）
        客户端收到后，响应服务端ACK=y+2

        断开步骤不分开会造成服务器半链接状态。tcp是全双工通信，双向通信。
        收到主动方发来的FIN报，被动方会立刻回答主动方，让主动方进入FIN-WAIT-1状态。防止主动方重复的发FIN报

      优化：
        1，带宽，考虑服务器压力能不能承受
        2，
    3，Request
      发送请求
    4，Response
      获取到数据
      后台给数据的时间
  
  c，浏览器处理阶段

    渲染引擎：
      Trident  IE
      Gecko    Firfox
      Webkit   Safari 
      Blink    Chrome

    1，htmlParser 构建dom，生成文档对象模型，做容错。没闭合的标签帮你闭合
    2，资源加载，引用的资源，依赖的 css，js。js会阻塞dom解析，js如果是异步加载，就不会影响
    3，根据规则生成渲染书 render
    4，生成绘制的规则 layout
    5，painting 绘制

    注意点：1，dom解析和css解析，是一个并行的进程，所以css不会阻塞dom解析
            2，render tree 依赖 dom和css，所以必须要等到css解析完才能render，
                所以css加载阻塞dom渲染
            3，css加载会阻塞js
            4，js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，
                等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，所以js阻塞dom解析
            5，defer属性表示延迟脚本执行，但是不会延迟下载 ，浏览器遇到script立即下载，
               顺序是书写顺序,文档解析完成时，脚本被执行，此时也会触发domcontentloaded事件，优先执行脚本
            6，async让浏览器异步加载js，加载js的时候，浏览器继续标签解析，顺序不确定，
                异步脚本一定会在load事件之前执行，但可能会在domcontentloaded事件之前或者之后执行。
            7，css加载会阻塞js的执行，但是不会阻塞js的下载，js的执行，dom的渲染，都要依赖css

传说中的性能优化：
  1，控制dom数量
  2，合并文件，文件或变大，webpack给出一个标准，30kb。并发数为5个
  3，
  
白屏的原因：


CSR: 
  vue:需要等待vuemainjs，router，ajax等待时间太长
  不依赖数据

SSR: 
  加载时长，需要等待服务端渲染完毕
  切换页面的时候，重复加载
  SEO优化
  可见即可得

同构：
  SEO优化，
  
