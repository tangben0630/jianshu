url到页面流程三个部分（a,b,c）：
  提示：1，计算机是不能认识url的，需要DNS解析出ip地址。
        2，复制大文件快，资源集中在磁盘的一个扇区上面，涉及到寻址操作。
        3，tcp的特性，刚开始速度快，后面速度慢，所以网络文件尽量小一点
  
  http：
    1.0与1.1的区别：
      1，缓存处理，1.0只要使用expires，1.1 e-tag
      2，长链接，keep-alive
      3，新增状态码
      4，优化带宽3

    2.0与1.1的区别：
      1，二进制传输
      2，服务端推送
      3，多路复用
      4，头部压缩

  a：浏览器本地的操作
    1，Prompt for unload
      我们在页面输入url的时候，首先会卸载掉原来的页面。
      目的是释放原来页面占据的内存。
    2，redirect
      先从本地缓存中查找请求内容，事实上，每次从网络请求文件后，文件都会被缓存在一个指定区域。
      优化IO操作，让cpu少做网络请求
    3，App cache
      网络操作，I/O 是最慢的操作

  b：网络操作 I/O
    1，DNS
      将url解析成ip地址
      CDN：
    2，TCP
      拿到ip地址后，建立tcp链接，想要进行http请求，必须进行tcp链接，tcp属于链路层，http应用层
      tcp作用就是链接对应的服务器ip地址
      tcp的特性，刚开始速度快，后面速度慢，所以网络文件尽量小一点
      五层协议：物理层，数据链路层（原始数据包），网络层，传输层，应用层

      发送方：发送一个url，应用层封装http协议头，http层封装相当于在url外面包了一层东西，向下传给传输层，
              传输层再次封包传给网络层，一直到物理层，转化为电信号。传给另一端。
      接收方：物理层接收，向上传到ip层，到网络层分包，再向上到tcp，tcp需要知道这个包的数据是哪个进程所需要的。
              浏览器拿到后，取出数据，给浏览器。
      如果有的包发送出错，会重新传送。

      传说中的三次握手：
        seq number：int  顺序号：一个int四个字节，主动发起方维护
        ack number：int  应答号：被动连接放维护   seq + ack  保证了发送双方的关系

        机制：发起连接的是客户端
          首先客户端客户端发起一个SYN指令，发送一个顺序号 seq = x，发送后，客户端处于半链接状态，等待响应
          服务端一直在监听有没有包发过来。收到包的时候 响应SYN_RCVE，应答号为 ACK = x+1，并且发送一个自己的 seq = y
          收到响应后，需要告诉服务器，发送一个应答号 ACK = y+1
          双方都有一个顺序号，响应号都是在顺序号的基础上面+1
      
      传送中的四次挥手：
        首先客户端发送 FIN指令，seq = x+2（因为握手的时候响应的ACK = x+1），ACK=y+1 表示自己将要断开
        服务端收到指令，首先响应客户端 ACK=x+3，
        服务端收尾完成就会发送一个FIN的包给客户端 seq=y+1（这里是响应之前客户端响应服务端的号）
        客户端收到后，响应服务端ACK=y+2

        断开步骤不分开会造成服务器半链接状态。tcp是全双工通信，双向通信。
        收到主动方发来的FIN报，被动方会立刻回答主动方，让主动方进入FIN-WAIT-1状态。防止主动方重复的发FIN报

      优化：
        1，带宽，考虑服务器压力能不能承受
        2，
    3，Request
      发送请求
    4，Response
      获取到数据
      后台给数据的时间
  
  c，浏览器处理阶段

    渲染引擎：
      Trident  IE
      Gecko    Firfox
      Webkit   Safari 
      Blink    Chrome

    1，htmlParser 构建dom，生成文档对象模型，做容错。没闭合的标签帮你闭合
    2，资源加载，引用的资源，依赖的 css，js。js会阻塞dom解析，js如果是异步加载，就不会影响
    3，根据规则生成渲染书 render
    4，生成绘制的规则 layout
    5，painting 绘制

    注意点：1，dom解析和css解析，是一个并行的进程，所以css不会阻塞dom解析
            2，render tree 依赖 dom和css，所以必须要等到css解析完才能render，
                所以css加载阻塞dom渲染
            3，css加载会阻塞js
            4，js中可能会创建，删除节点等，这些操作会对dom树产生影响，如果不阻塞，
                等浏览器解析完标签生成dom树后，js修改了某些节点，那么浏览器又得重新解析，所以js阻塞dom解析
            5，defer属性表示延迟脚本执行，但是不会延迟下载 ，浏览器遇到script立即下载，
               顺序是书写顺序,文档解析完成时，脚本被执行，此时也会触发domcontentloaded事件，优先执行脚本
            6，async让浏览器异步加载js，加载js的时候，浏览器继续标签解析，顺序不确定，
                异步脚本一定会在load事件之前执行，但可能会在domcontentloaded事件之前或者之后执行。
            7，css加载会阻塞js的执行，但是不会阻塞js的下载，js的执行，dom的渲染，都要依赖css

http：
  1.0与1.1的区别：
    1，缓存处理，1.0只要使用expires，1.1 e-tag
    2，长链接，keep-alive
    3，新增状态码
    4，优化带宽

  2.0与1.1的区别：
    1，二进制传输
    2，服务端推送
    3，多路复用
    4，头部压缩

传说中的性能优化：
  1，控制dom数量
  2，合并文件，文件或变大，webpack给出一个标准，30kb。并发数为5个
  3，
  
白屏的原因：


CSR: 
  vue:需要等待vuemainjs，router，ajax等待时间太长
  不依赖数据

SSR: 
  加载时长，需要等待服务端渲染完毕
  切换页面的时候，重复加载
  SEO优化
  可见即可得

同构：
  SEO优化，




2021-6-9

  优化:

    第一个阶段 1-4
    1, unload: 清除上次的缓存, 卸载上一个页面

    2, redirect: 检查有没有缓存, 有的话从本地拿, 没有的话走请求

                协商缓存
                强制缓存: 非常快

    3, DNS解析 

        用户配置    路由器 ---> 电信拨号 --->  
        DNS: 把域名转化成 IP
        baidu.com     ---> 一级域名
        www.baidu.com ---> 二级域名

        1, 一般宽带服务商都会提供DNS服务器
        2, 当一台设备连接到路由器后, 路由器给他分配一个ip地址, 并告诉他DNS服务器
        3, Chrome 会获取系统的 DNS 服务器

        1, 在浏览器发出请求之前, 计算机会拦截每个请求并在DNS数据库中查找域名地址, 
        2, Dos攻击: 让重要的DNS服务器过载, 使得DNS查询不起作用
        3, DNS劫持: 攻击者将查询重定向到其他域名服务器

        1, 浏览器会在自身DNS缓存中查找
        2, 从操作系统中查找
        3, 在hosts文件里面查找
        4, 请求本地域名服务器  中国移动,电信,联通 提供
        5, 都没有, 请求根服务器
        6, 从左向右, 挨个解析  .com   baidu.com   test.baidu.com
        7, 分层
        优化:
          1, 尽量减少DNS查询时间, 减少不同域名大请求数量, 将外部资源提前下载到同域名的服务器上
          2, 加载html会自动解析a标签所包含的href链接转为ip地址 <link rel="dns-prefetch" href="//img.alicdn.com">


        CDN:
          Address记录, 可以理解为一种指向关系

            abc.com   ======> 198.161.58.12
            bcd.com   ======> 198.161.58.12

          CNAME记录:

            aaaa   =====> abc.com
            bbbb   =====> abc.com

            CDN 的全称是: Content Delivery Network 内容分发网络. 目的是通过现有的Internet流程中添加一层新的
                          网络架构, 将网站的内容, 发布到最接近用户的网络"边缘", 使用户就近取得所需内容, 
                          解决拥堵现象

            1, CDN 会根据用户ip地址, 判断哪一台服务器距离用户最近
            2, 根据用户请求url中的内容, 判断哪一台服务器上有用户所需要的内容
            3, 查询各个服务器负载情况, 判断哪一台负载最小

        
        

    4, TCP

      a, 链路本身问题, 比如带宽不足
      b, 配合DNS做 CDN

    第二个阶段 5-6  请求与响应

    request 的时候在服务器端加上 gizped

    5, http缓存:

      1, Expires: 响应头, 代表该资源过期时间
                  规定时间内, 拿缓存,过期重新请求

      2, Cache-Control: 请求/响应头, 精确控制缓存策略

                浏览器优先查找 Cache-Control, 优先以Cache-Control为准, 没有Cache-Control则以Expires为准


      3, if-Modified-Since: 请求头, 资源最近修改时间, 由浏览器告诉服务器
                            当文件过期时, 浏览器带上 if-Modified-Since 时间的值
                            就是 上次浏览器返回的 Last-Modified 

      4, Last-Modified: 响应头, 资源最近修改时间, 服务器告诉浏览器
                        服务器每次返回文件时候, 告诉浏览器修改的时间, 以及缓存过期时间

          3,4, : 服务器比较请求头里的 Last-Modified 时间和文件的上次修改时间
                1, 如果一致, 可以使用本地缓存(304),.
                2, 不一致, 服务器读取磁盘上的文件, 返回给浏览器同时告诉浏览器修改时间以及过期时间


      5, Etag: 响应头, 资源标识, 服务器告诉浏览器

              文件内容的唯一ID, 配合请求头 if-None-Match 
              服务器优先比较 if-None-Match, 跟文件的 Etag值, 

      6, if-None-Match: 请求头, 缓存资源标识, 浏览器告诉服务器

      7, if-Modified-Since <====> Last-Modified
      8, Etag  <====>   if-None-Match

    
    5, http缓存-2:

      强制缓存 优先级高于 协商缓存

      强制缓存:

        对于强制缓存, header会用两个字段来表明 ---- Expires 和 Cache-Control
            1, Expires: http 1.0 产物. 表示资源的到期时间, 
            2, Cache-Control: 1.1 的产物, max-age = time 时间精确到秒

      协商缓存: 

        Last-Modified: 服务器在响应时, 告诉浏览器资源最后的修改时间

        if-Modified-Since: 浏览器再次请求服务器的时候, 请求头会包含此字段, 后面跟着缓存中获得
                            最后修改时间. 服务器接收到这个字段, 没过期返回 304 过期 200 并且返回资源
        
        Etag: 服务器响应请求时, 通过此字段告诉浏览器当前资源在服务器生成的唯一标识
        if-None-Match: 请求时, 报文头部加入这个字段, 
        








    
